// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: db_item.proto

package mpb

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type DBBaseEquip struct {
	EquipType            EItem_BaseEquipType `protobuf:"varint,1,opt,name=equip_type,json=equipType,proto3,enum=mpb.EItem_BaseEquipType" json:"equip_type,omitempty"`
	Star                 uint32              `protobuf:"varint,2,opt,name=star,proto3" json:"star,omitempty"`
	Level                uint32              `protobuf:"varint,3,opt,name=level,proto3" json:"level,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *DBBaseEquip) Reset()         { *m = DBBaseEquip{} }
func (m *DBBaseEquip) String() string { return proto.CompactTextString(m) }
func (*DBBaseEquip) ProtoMessage()    {}
func (*DBBaseEquip) Descriptor() ([]byte, []int) {
	return fileDescriptor_7acb839e425208fc, []int{0}
}
func (m *DBBaseEquip) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DBBaseEquip) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DBBaseEquip.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DBBaseEquip) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DBBaseEquip.Merge(m, src)
}
func (m *DBBaseEquip) XXX_Size() int {
	return m.Size()
}
func (m *DBBaseEquip) XXX_DiscardUnknown() {
	xxx_messageInfo_DBBaseEquip.DiscardUnknown(m)
}

var xxx_messageInfo_DBBaseEquip proto.InternalMessageInfo

func (m *DBBaseEquip) GetEquipType() EItem_BaseEquipType {
	if m != nil {
		return m.EquipType
	}
	return EItem_BaseEquipType_None
}

func (m *DBBaseEquip) GetStar() uint32 {
	if m != nil {
		return m.Star
	}
	return 0
}

func (m *DBBaseEquip) GetLevel() uint32 {
	if m != nil {
		return m.Level
	}
	return 0
}

type DBBaseEquips struct {
	Equips                  map[uint32]*DBBaseEquip `protobuf:"bytes,1,rep,name=equips,proto3" json:"equips,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	UpgradeStarFailedTimes  map[uint32]uint32       `protobuf:"bytes,2,rep,name=upgrade_star_failed_times,json=upgradeStarFailedTimes,proto3" json:"upgrade_star_failed_times,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	UpgradeLevelFailedTimes map[uint32]uint32       `protobuf:"bytes,3,rep,name=upgrade_level_failed_times,json=upgradeLevelFailedTimes,proto3" json:"upgrade_level_failed_times,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral    struct{}                `json:"-"`
	XXX_unrecognized        []byte                  `json:"-"`
	XXX_sizecache           int32                   `json:"-"`
}

func (m *DBBaseEquips) Reset()         { *m = DBBaseEquips{} }
func (m *DBBaseEquips) String() string { return proto.CompactTextString(m) }
func (*DBBaseEquips) ProtoMessage()    {}
func (*DBBaseEquips) Descriptor() ([]byte, []int) {
	return fileDescriptor_7acb839e425208fc, []int{1}
}
func (m *DBBaseEquips) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DBBaseEquips) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DBBaseEquips.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DBBaseEquips) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DBBaseEquips.Merge(m, src)
}
func (m *DBBaseEquips) XXX_Size() int {
	return m.Size()
}
func (m *DBBaseEquips) XXX_DiscardUnknown() {
	xxx_messageInfo_DBBaseEquips.DiscardUnknown(m)
}

var xxx_messageInfo_DBBaseEquips proto.InternalMessageInfo

func (m *DBBaseEquips) GetEquips() map[uint32]*DBBaseEquip {
	if m != nil {
		return m.Equips
	}
	return nil
}

func (m *DBBaseEquips) GetUpgradeStarFailedTimes() map[uint32]uint32 {
	if m != nil {
		return m.UpgradeStarFailedTimes
	}
	return nil
}

func (m *DBBaseEquips) GetUpgradeLevelFailedTimes() map[uint32]uint32 {
	if m != nil {
		return m.UpgradeLevelFailedTimes
	}
	return nil
}

type DBItem struct {
	ItemId               uint32   `protobuf:"varint,1,opt,name=item_id,json=itemId,proto3" json:"item_id,omitempty"`
	Num                  uint64   `protobuf:"varint,2,opt,name=num,proto3" json:"num,omitempty"`
	Uuid                 uint64   `protobuf:"varint,3,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ExpireAt             int64    `protobuf:"varint,4,opt,name=expire_at,json=expireAt,proto3" json:"expire_at,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DBItem) Reset()         { *m = DBItem{} }
func (m *DBItem) String() string { return proto.CompactTextString(m) }
func (*DBItem) ProtoMessage()    {}
func (*DBItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_7acb839e425208fc, []int{2}
}
func (m *DBItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DBItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DBItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DBItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DBItem.Merge(m, src)
}
func (m *DBItem) XXX_Size() int {
	return m.Size()
}
func (m *DBItem) XXX_DiscardUnknown() {
	xxx_messageInfo_DBItem.DiscardUnknown(m)
}

var xxx_messageInfo_DBItem proto.InternalMessageInfo

func (m *DBItem) GetItemId() uint32 {
	if m != nil {
		return m.ItemId
	}
	return 0
}

func (m *DBItem) GetNum() uint64 {
	if m != nil {
		return m.Num
	}
	return 0
}

func (m *DBItem) GetUuid() uint64 {
	if m != nil {
		return m.Uuid
	}
	return 0
}

func (m *DBItem) GetExpireAt() int64 {
	if m != nil {
		return m.ExpireAt
	}
	return 0
}

type DBItemListShard struct {
	Items                map[uint32]*DBItem `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *DBItemListShard) Reset()         { *m = DBItemListShard{} }
func (m *DBItemListShard) String() string { return proto.CompactTextString(m) }
func (*DBItemListShard) ProtoMessage()    {}
func (*DBItemListShard) Descriptor() ([]byte, []int) {
	return fileDescriptor_7acb839e425208fc, []int{3}
}
func (m *DBItemListShard) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DBItemListShard) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DBItemListShard.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DBItemListShard) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DBItemListShard.Merge(m, src)
}
func (m *DBItemListShard) XXX_Size() int {
	return m.Size()
}
func (m *DBItemListShard) XXX_DiscardUnknown() {
	xxx_messageInfo_DBItemListShard.DiscardUnknown(m)
}

var xxx_messageInfo_DBItemListShard proto.InternalMessageInfo

func (m *DBItemListShard) GetItems() map[uint32]*DBItem {
	if m != nil {
		return m.Items
	}
	return nil
}

type DBUItemListShard struct {
	ItemNums             map[uint32]uint32  `protobuf:"bytes,1,rep,name=item_nums,json=itemNums,proto3" json:"item_nums,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Items                map[uint64]*DBItem `protobuf:"bytes,2,rep,name=items,proto3" json:"items,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *DBUItemListShard) Reset()         { *m = DBUItemListShard{} }
func (m *DBUItemListShard) String() string { return proto.CompactTextString(m) }
func (*DBUItemListShard) ProtoMessage()    {}
func (*DBUItemListShard) Descriptor() ([]byte, []int) {
	return fileDescriptor_7acb839e425208fc, []int{4}
}
func (m *DBUItemListShard) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DBUItemListShard) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DBUItemListShard.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DBUItemListShard) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DBUItemListShard.Merge(m, src)
}
func (m *DBUItemListShard) XXX_Size() int {
	return m.Size()
}
func (m *DBUItemListShard) XXX_DiscardUnknown() {
	xxx_messageInfo_DBUItemListShard.DiscardUnknown(m)
}

var xxx_messageInfo_DBUItemListShard proto.InternalMessageInfo

func (m *DBUItemListShard) GetItemNums() map[uint32]uint32 {
	if m != nil {
		return m.ItemNums
	}
	return nil
}

func (m *DBUItemListShard) GetItems() map[uint64]*DBItem {
	if m != nil {
		return m.Items
	}
	return nil
}

type DBWallet struct {
	Mana                 uint64   `protobuf:"varint,1,opt,name=mana,proto3" json:"mana,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DBWallet) Reset()         { *m = DBWallet{} }
func (m *DBWallet) String() string { return proto.CompactTextString(m) }
func (*DBWallet) ProtoMessage()    {}
func (*DBWallet) Descriptor() ([]byte, []int) {
	return fileDescriptor_7acb839e425208fc, []int{5}
}
func (m *DBWallet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DBWallet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DBWallet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DBWallet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DBWallet.Merge(m, src)
}
func (m *DBWallet) XXX_Size() int {
	return m.Size()
}
func (m *DBWallet) XXX_DiscardUnknown() {
	xxx_messageInfo_DBWallet.DiscardUnknown(m)
}

var xxx_messageInfo_DBWallet proto.InternalMessageInfo

func (m *DBWallet) GetMana() uint64 {
	if m != nil {
		return m.Mana
	}
	return 0
}

func init() {
	proto.RegisterType((*DBBaseEquip)(nil), "mpb.DBBaseEquip")
	proto.RegisterType((*DBBaseEquips)(nil), "mpb.DBBaseEquips")
	proto.RegisterMapType((map[uint32]*DBBaseEquip)(nil), "mpb.DBBaseEquips.EquipsEntry")
	proto.RegisterMapType((map[uint32]uint32)(nil), "mpb.DBBaseEquips.UpgradeLevelFailedTimesEntry")
	proto.RegisterMapType((map[uint32]uint32)(nil), "mpb.DBBaseEquips.UpgradeStarFailedTimesEntry")
	proto.RegisterType((*DBItem)(nil), "mpb.DBItem")
	proto.RegisterType((*DBItemListShard)(nil), "mpb.DBItemListShard")
	proto.RegisterMapType((map[uint32]*DBItem)(nil), "mpb.DBItemListShard.ItemsEntry")
	proto.RegisterType((*DBUItemListShard)(nil), "mpb.DBUItemListShard")
	proto.RegisterMapType((map[uint32]uint32)(nil), "mpb.DBUItemListShard.ItemNumsEntry")
	proto.RegisterMapType((map[uint64]*DBItem)(nil), "mpb.DBUItemListShard.ItemsEntry")
	proto.RegisterType((*DBWallet)(nil), "mpb.DBWallet")
}

func init() { proto.RegisterFile("db_item.proto", fileDescriptor_7acb839e425208fc) }

var fileDescriptor_7acb839e425208fc = []byte{
	// 540 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0x51, 0x8f, 0xd2, 0x40,
	0x10, 0x76, 0x69, 0x41, 0x18, 0x0e, 0x25, 0x9b, 0x8b, 0x54, 0x4e, 0x11, 0x31, 0x31, 0xbc, 0x58,
	0x13, 0xcc, 0xa9, 0xd1, 0x17, 0x6d, 0xc0, 0x04, 0xbd, 0xf8, 0xd0, 0x3b, 0x62, 0xe2, 0x4b, 0xb3,
	0xd8, 0xd5, 0x6b, 0xae, 0x2d, 0x6b, 0xbb, 0x7b, 0x91, 0x37, 0xff, 0x81, 0x3e, 0xfa, 0x93, 0x7c,
	0xf4, 0x27, 0x18, 0xfc, 0x23, 0x66, 0x77, 0xdb, 0xb3, 0x15, 0xb8, 0x84, 0xa7, 0xce, 0xcc, 0xce,
	0x7c, 0xdf, 0x7c, 0x33, 0x93, 0x42, 0xcb, 0x9f, 0x7b, 0x01, 0xa7, 0x91, 0xcd, 0x92, 0x05, 0x5f,
	0x60, 0x23, 0x62, 0xf3, 0xee, 0xde, 0x87, 0x45, 0x14, 0x2d, 0x62, 0x1d, 0x1a, 0x30, 0x68, 0x8e,
	0x1d, 0x87, 0xa4, 0x74, 0xf2, 0x59, 0x04, 0x0c, 0x3f, 0x01, 0xa0, 0xd2, 0xf0, 0xf8, 0x92, 0x51,
	0x0b, 0xf5, 0xd1, 0xf0, 0xda, 0xc8, 0xb2, 0x23, 0x36, 0xb7, 0x27, 0x53, 0x89, 0x73, 0x91, 0x79,
	0xb2, 0x64, 0xd4, 0x6d, 0xd0, 0xdc, 0xc4, 0x18, 0xcc, 0x94, 0x93, 0xc4, 0xaa, 0xf4, 0xd1, 0xb0,
	0xe5, 0x2a, 0x1b, 0xef, 0x43, 0x35, 0xa4, 0xe7, 0x34, 0xb4, 0x0c, 0x15, 0xd4, 0xce, 0xe0, 0xab,
	0x09, 0x7b, 0x05, 0xca, 0x14, 0x1f, 0x42, 0x4d, 0xe1, 0xa4, 0x16, 0xea, 0x1b, 0xc3, 0xe6, 0xe8,
	0xb6, 0xe2, 0x2b, 0xa6, 0xd8, 0xfa, 0x33, 0x89, 0x79, 0xb2, 0x74, 0xb3, 0x64, 0x7c, 0x0a, 0x37,
	0x05, 0xfb, 0x94, 0x10, 0x9f, 0x7a, 0x92, 0xcd, 0xfb, 0x48, 0x82, 0x90, 0xfa, 0x1e, 0x0f, 0x22,
	0x9a, 0x5a, 0x15, 0x85, 0xf4, 0x60, 0x1d, 0x69, 0xa6, 0x4b, 0x8e, 0x39, 0x49, 0x5e, 0xa9, 0x82,
	0x13, 0x99, 0xaf, 0x91, 0x6f, 0x88, 0x8d, 0x8f, 0xf8, 0x0c, 0xba, 0x39, 0x93, 0x92, 0x50, 0xa6,
	0x32, 0x14, 0x95, 0xbd, 0x95, 0xea, 0x48, 0x96, 0xac, 0x71, 0x75, 0xc4, 0xe6, 0xd7, 0xee, 0x1b,
	0x68, 0x16, 0xd4, 0xe2, 0x36, 0x18, 0x67, 0x74, 0xa9, 0x36, 0xd1, 0x72, 0xa5, 0x89, 0xef, 0x43,
	0xf5, 0x9c, 0x84, 0x82, 0xaa, 0x51, 0x37, 0x47, 0xed, 0xff, 0x89, 0x5d, 0xfd, 0xfc, 0xac, 0xf2,
	0x14, 0x75, 0xa7, 0x70, 0x70, 0x89, 0xe0, 0x0d, 0xe0, 0xfb, 0x45, 0xf0, 0x56, 0x11, 0xea, 0x35,
	0xdc, 0xba, 0x4c, 0xd0, 0x2e, 0x58, 0x03, 0x1f, 0x6a, 0x63, 0x47, 0xde, 0x13, 0xee, 0xc0, 0x55,
	0x79, 0x9f, 0x5e, 0xe0, 0x67, 0x95, 0x35, 0xe9, 0x4e, 0x7d, 0x09, 0x17, 0x8b, 0x48, 0x95, 0x9a,
	0xae, 0x34, 0xe5, 0x85, 0x09, 0x11, 0xf8, 0xea, 0x98, 0x4c, 0x57, 0xd9, 0xf8, 0x00, 0x1a, 0xf4,
	0x0b, 0x0b, 0x12, 0xea, 0x11, 0x6e, 0x99, 0x7d, 0x34, 0x34, 0xdc, 0xba, 0x0e, 0xbc, 0xe4, 0x83,
	0x6f, 0x08, 0xae, 0x6b, 0x9a, 0xa3, 0x20, 0xe5, 0xc7, 0xa7, 0x24, 0xf1, 0xf1, 0x21, 0x54, 0x25,
	0x41, 0x7e, 0x6a, 0x77, 0xb2, 0xe1, 0x95, 0x92, 0x6c, 0xe9, 0x65, 0x6b, 0xd2, 0xd9, 0xdd, 0x09,
	0xc0, 0xbf, 0xe0, 0x06, 0xa9, 0x77, 0xcb, 0x3b, 0x69, 0x16, 0x60, 0x8b, 0xba, 0xbf, 0x57, 0xa0,
	0x3d, 0x76, 0x66, 0xe5, 0x96, 0x5e, 0x40, 0x43, 0x8d, 0x20, 0x16, 0x17, 0x6d, 0xdd, 0xcb, 0xea,
	0x67, 0xeb, 0x7d, 0xbd, 0x15, 0x79, 0x6b, 0xf5, 0x20, 0x73, 0xf1, 0xe3, 0x5c, 0x94, 0xbe, 0xfa,
	0xfe, 0xf6, 0xea, 0xb2, 0xaa, 0xe7, 0xd0, 0x2a, 0x41, 0xee, 0x74, 0x0f, 0x5b, 0x47, 0x62, 0xee,
	0x34, 0x92, 0x1e, 0xd4, 0xc7, 0xce, 0x3b, 0x12, 0x86, 0x94, 0xcb, 0x0d, 0x47, 0x24, 0x26, 0x19,
	0x8a, 0xb2, 0x9d, 0xce, 0xcf, 0x55, 0x0f, 0xfd, 0x5a, 0xf5, 0xd0, 0xef, 0x55, 0x0f, 0xfd, 0xf8,
	0xd3, 0xbb, 0xf2, 0xbe, 0x6a, 0x3f, 0x8c, 0xd8, 0x7c, 0x5e, 0x53, 0xff, 0xaf, 0x47, 0x7f, 0x03,
	0x00, 0x00, 0xff, 0xff, 0x24, 0x18, 0xd7, 0x4a, 0xe3, 0x04, 0x00, 0x00,
}

func (m *DBBaseEquip) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DBBaseEquip) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DBBaseEquip) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Level != 0 {
		i = encodeVarintDbItem(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x18
	}
	if m.Star != 0 {
		i = encodeVarintDbItem(dAtA, i, uint64(m.Star))
		i--
		dAtA[i] = 0x10
	}
	if m.EquipType != 0 {
		i = encodeVarintDbItem(dAtA, i, uint64(m.EquipType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DBBaseEquips) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DBBaseEquips) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DBBaseEquips) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UpgradeLevelFailedTimes) > 0 {
		for k := range m.UpgradeLevelFailedTimes {
			v := m.UpgradeLevelFailedTimes[k]
			baseI := i
			i = encodeVarintDbItem(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintDbItem(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintDbItem(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.UpgradeStarFailedTimes) > 0 {
		for k := range m.UpgradeStarFailedTimes {
			v := m.UpgradeStarFailedTimes[k]
			baseI := i
			i = encodeVarintDbItem(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintDbItem(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintDbItem(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Equips) > 0 {
		for k := range m.Equips {
			v := m.Equips[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintDbItem(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintDbItem(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintDbItem(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DBItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DBItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DBItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ExpireAt != 0 {
		i = encodeVarintDbItem(dAtA, i, uint64(m.ExpireAt))
		i--
		dAtA[i] = 0x20
	}
	if m.Uuid != 0 {
		i = encodeVarintDbItem(dAtA, i, uint64(m.Uuid))
		i--
		dAtA[i] = 0x18
	}
	if m.Num != 0 {
		i = encodeVarintDbItem(dAtA, i, uint64(m.Num))
		i--
		dAtA[i] = 0x10
	}
	if m.ItemId != 0 {
		i = encodeVarintDbItem(dAtA, i, uint64(m.ItemId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DBItemListShard) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DBItemListShard) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DBItemListShard) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Items) > 0 {
		for k := range m.Items {
			v := m.Items[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintDbItem(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintDbItem(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintDbItem(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DBUItemListShard) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DBUItemListShard) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DBUItemListShard) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Items) > 0 {
		for k := range m.Items {
			v := m.Items[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintDbItem(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintDbItem(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintDbItem(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ItemNums) > 0 {
		for k := range m.ItemNums {
			v := m.ItemNums[k]
			baseI := i
			i = encodeVarintDbItem(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintDbItem(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintDbItem(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DBWallet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DBWallet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DBWallet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Mana != 0 {
		i = encodeVarintDbItem(dAtA, i, uint64(m.Mana))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintDbItem(dAtA []byte, offset int, v uint64) int {
	offset -= sovDbItem(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *DBBaseEquip) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EquipType != 0 {
		n += 1 + sovDbItem(uint64(m.EquipType))
	}
	if m.Star != 0 {
		n += 1 + sovDbItem(uint64(m.Star))
	}
	if m.Level != 0 {
		n += 1 + sovDbItem(uint64(m.Level))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DBBaseEquips) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Equips) > 0 {
		for k, v := range m.Equips {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovDbItem(uint64(l))
			}
			mapEntrySize := 1 + sovDbItem(uint64(k)) + l
			n += mapEntrySize + 1 + sovDbItem(uint64(mapEntrySize))
		}
	}
	if len(m.UpgradeStarFailedTimes) > 0 {
		for k, v := range m.UpgradeStarFailedTimes {
			_ = k
			_ = v
			mapEntrySize := 1 + sovDbItem(uint64(k)) + 1 + sovDbItem(uint64(v))
			n += mapEntrySize + 1 + sovDbItem(uint64(mapEntrySize))
		}
	}
	if len(m.UpgradeLevelFailedTimes) > 0 {
		for k, v := range m.UpgradeLevelFailedTimes {
			_ = k
			_ = v
			mapEntrySize := 1 + sovDbItem(uint64(k)) + 1 + sovDbItem(uint64(v))
			n += mapEntrySize + 1 + sovDbItem(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DBItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ItemId != 0 {
		n += 1 + sovDbItem(uint64(m.ItemId))
	}
	if m.Num != 0 {
		n += 1 + sovDbItem(uint64(m.Num))
	}
	if m.Uuid != 0 {
		n += 1 + sovDbItem(uint64(m.Uuid))
	}
	if m.ExpireAt != 0 {
		n += 1 + sovDbItem(uint64(m.ExpireAt))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DBItemListShard) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for k, v := range m.Items {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovDbItem(uint64(l))
			}
			mapEntrySize := 1 + sovDbItem(uint64(k)) + l
			n += mapEntrySize + 1 + sovDbItem(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DBUItemListShard) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ItemNums) > 0 {
		for k, v := range m.ItemNums {
			_ = k
			_ = v
			mapEntrySize := 1 + sovDbItem(uint64(k)) + 1 + sovDbItem(uint64(v))
			n += mapEntrySize + 1 + sovDbItem(uint64(mapEntrySize))
		}
	}
	if len(m.Items) > 0 {
		for k, v := range m.Items {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovDbItem(uint64(l))
			}
			mapEntrySize := 1 + sovDbItem(uint64(k)) + l
			n += mapEntrySize + 1 + sovDbItem(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DBWallet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mana != 0 {
		n += 1 + sovDbItem(uint64(m.Mana))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovDbItem(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozDbItem(x uint64) (n int) {
	return sovDbItem(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DBBaseEquip) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDbItem
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DBBaseEquip: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DBBaseEquip: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EquipType", wireType)
			}
			m.EquipType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDbItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EquipType |= EItem_BaseEquipType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Star", wireType)
			}
			m.Star = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDbItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Star |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDbItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDbItem(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDbItem
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DBBaseEquips) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDbItem
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DBBaseEquips: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DBBaseEquips: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Equips", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDbItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDbItem
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDbItem
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Equips == nil {
				m.Equips = make(map[uint32]*DBBaseEquip)
			}
			var mapkey uint32
			var mapvalue *DBBaseEquip
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDbItem
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDbItem
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDbItem
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthDbItem
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthDbItem
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &DBBaseEquip{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipDbItem(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthDbItem
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Equips[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpgradeStarFailedTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDbItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDbItem
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDbItem
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpgradeStarFailedTimes == nil {
				m.UpgradeStarFailedTimes = make(map[uint32]uint32)
			}
			var mapkey uint32
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDbItem
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDbItem
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDbItem
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipDbItem(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthDbItem
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.UpgradeStarFailedTimes[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpgradeLevelFailedTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDbItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDbItem
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDbItem
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpgradeLevelFailedTimes == nil {
				m.UpgradeLevelFailedTimes = make(map[uint32]uint32)
			}
			var mapkey uint32
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDbItem
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDbItem
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDbItem
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipDbItem(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthDbItem
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.UpgradeLevelFailedTimes[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDbItem(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDbItem
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DBItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDbItem
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DBItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DBItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			m.ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDbItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDbItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			m.Uuid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDbItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uuid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpireAt", wireType)
			}
			m.ExpireAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDbItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpireAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDbItem(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDbItem
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DBItemListShard) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDbItem
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DBItemListShard: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DBItemListShard: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDbItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDbItem
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDbItem
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Items == nil {
				m.Items = make(map[uint32]*DBItem)
			}
			var mapkey uint32
			var mapvalue *DBItem
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDbItem
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDbItem
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDbItem
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthDbItem
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthDbItem
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &DBItem{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipDbItem(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthDbItem
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Items[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDbItem(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDbItem
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DBUItemListShard) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDbItem
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DBUItemListShard: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DBUItemListShard: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemNums", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDbItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDbItem
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDbItem
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ItemNums == nil {
				m.ItemNums = make(map[uint32]uint32)
			}
			var mapkey uint32
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDbItem
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDbItem
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDbItem
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipDbItem(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthDbItem
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ItemNums[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDbItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDbItem
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDbItem
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Items == nil {
				m.Items = make(map[uint64]*DBItem)
			}
			var mapkey uint64
			var mapvalue *DBItem
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDbItem
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDbItem
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDbItem
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthDbItem
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthDbItem
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &DBItem{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipDbItem(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthDbItem
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Items[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDbItem(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDbItem
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DBWallet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDbItem
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DBWallet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DBWallet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mana", wireType)
			}
			m.Mana = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDbItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mana |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDbItem(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDbItem
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDbItem(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDbItem
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDbItem
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDbItem
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDbItem
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupDbItem
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthDbItem
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthDbItem        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDbItem          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupDbItem = fmt.Errorf("proto: unexpected end of group")
)
