// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: db_market.proto

package mpb

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type DBGoodsOrder struct {
	OrderUuid            uint64   `protobuf:"varint,1,opt,name=order_uuid,json=orderUuid,proto3" json:"order_uuid,omitempty"`
	GoodsId              uint32   `protobuf:"varint,2,opt,name=goods_id,json=goodsId,proto3" json:"goods_id,omitempty"`
	GoodsNum             uint64   `protobuf:"varint,3,opt,name=goods_num,json=goodsNum,proto3" json:"goods_num,omitempty"`
	Price                uint64   `protobuf:"varint,4,opt,name=price,proto3" json:"price,omitempty"`
	Gas                  uint64   `protobuf:"varint,5,opt,name=gas,proto3" json:"gas,omitempty"`
	PublishAt            int64    `protobuf:"varint,6,opt,name=publish_at,json=publishAt,proto3" json:"publish_at,omitempty"`
	OpenAt               int64    `protobuf:"varint,7,opt,name=open_at,json=openAt,proto3" json:"open_at,omitempty"`
	SoldAt               int64    `protobuf:"varint,8,opt,name=sold_at,json=soldAt,proto3" json:"sold_at,omitempty"`
	Status               uint32   `protobuf:"varint,9,opt,name=status,proto3" json:"status,omitempty"`
	Seller               uint64   `protobuf:"varint,10,opt,name=seller,proto3" json:"seller,omitempty"`
	Buyer                uint64   `protobuf:"varint,11,opt,name=buyer,proto3" json:"buyer,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DBGoodsOrder) Reset()         { *m = DBGoodsOrder{} }
func (m *DBGoodsOrder) String() string { return proto.CompactTextString(m) }
func (*DBGoodsOrder) ProtoMessage()    {}
func (*DBGoodsOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_db3986fb2b3a382a, []int{0}
}
func (m *DBGoodsOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DBGoodsOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DBGoodsOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DBGoodsOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DBGoodsOrder.Merge(m, src)
}
func (m *DBGoodsOrder) XXX_Size() int {
	return m.Size()
}
func (m *DBGoodsOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_DBGoodsOrder.DiscardUnknown(m)
}

var xxx_messageInfo_DBGoodsOrder proto.InternalMessageInfo

func (m *DBGoodsOrder) GetOrderUuid() uint64 {
	if m != nil {
		return m.OrderUuid
	}
	return 0
}

func (m *DBGoodsOrder) GetGoodsId() uint32 {
	if m != nil {
		return m.GoodsId
	}
	return 0
}

func (m *DBGoodsOrder) GetGoodsNum() uint64 {
	if m != nil {
		return m.GoodsNum
	}
	return 0
}

func (m *DBGoodsOrder) GetPrice() uint64 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *DBGoodsOrder) GetGas() uint64 {
	if m != nil {
		return m.Gas
	}
	return 0
}

func (m *DBGoodsOrder) GetPublishAt() int64 {
	if m != nil {
		return m.PublishAt
	}
	return 0
}

func (m *DBGoodsOrder) GetOpenAt() int64 {
	if m != nil {
		return m.OpenAt
	}
	return 0
}

func (m *DBGoodsOrder) GetSoldAt() int64 {
	if m != nil {
		return m.SoldAt
	}
	return 0
}

func (m *DBGoodsOrder) GetStatus() uint32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *DBGoodsOrder) GetSeller() uint64 {
	if m != nil {
		return m.Seller
	}
	return 0
}

func (m *DBGoodsOrder) GetBuyer() uint64 {
	if m != nil {
		return m.Buyer
	}
	return 0
}

func init() {
	proto.RegisterType((*DBGoodsOrder)(nil), "mpb.DBGoodsOrder")
}

func init() { proto.RegisterFile("db_market.proto", fileDescriptor_db3986fb2b3a382a) }

var fileDescriptor_db3986fb2b3a382a = []byte{
	// 273 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x2c, 0x90, 0x4f, 0x4a, 0xc4, 0x30,
	0x14, 0xc6, 0xcd, 0x74, 0xa6, 0x9d, 0x3e, 0x15, 0x25, 0x88, 0x13, 0x11, 0x4b, 0x71, 0xd5, 0xd5,
	0xb8, 0xf0, 0x04, 0x33, 0x08, 0xe2, 0x46, 0xa1, 0xe0, 0xc6, 0x4d, 0x69, 0x4c, 0x18, 0x8b, 0xed,
	0x24, 0xe4, 0xcf, 0xc2, 0x9b, 0x78, 0x00, 0x0f, 0xe3, 0xd2, 0x23, 0x48, 0xbd, 0x88, 0xe4, 0xa5,
	0xbb, 0xf7, 0xfb, 0x7e, 0x2f, 0xbc, 0x8f, 0xc0, 0x89, 0xe0, 0xcd, 0xd0, 0x9a, 0x77, 0xe9, 0xd6,
	0xda, 0x28, 0xa7, 0x68, 0x32, 0x68, 0x7e, 0xfd, 0x35, 0x83, 0xa3, 0xbb, 0xed, 0xbd, 0x52, 0xc2,
	0x3e, 0x19, 0x21, 0x0d, 0xbd, 0x02, 0x50, 0x61, 0x68, 0xbc, 0xef, 0x04, 0x23, 0x25, 0xa9, 0xe6,
	0x75, 0x8e, 0xc9, 0xb3, 0xef, 0x04, 0xbd, 0x80, 0xe5, 0x2e, 0x2c, 0x37, 0x9d, 0x60, 0xb3, 0x92,
	0x54, 0xc7, 0x75, 0x86, 0xfc, 0x20, 0xe8, 0x25, 0xe4, 0x51, 0xed, 0xfd, 0xc0, 0x12, 0x7c, 0x18,
	0x77, 0x1f, 0xfd, 0x40, 0xcf, 0x60, 0xa1, 0x4d, 0xf7, 0x2a, 0xd9, 0x1c, 0x45, 0x04, 0x7a, 0x0a,
	0xc9, 0xae, 0xb5, 0x6c, 0x81, 0x59, 0x18, 0xc3, 0x79, 0xed, 0x79, 0xdf, 0xd9, 0xb7, 0xa6, 0x75,
	0x2c, 0x2d, 0x49, 0x95, 0xd4, 0xf9, 0x94, 0x6c, 0x1c, 0x5d, 0x41, 0xa6, 0xb4, 0xdc, 0x07, 0x97,
	0xa1, 0x4b, 0x03, 0x46, 0x61, 0x55, 0x2f, 0x82, 0x58, 0x46, 0x11, 0x70, 0xe3, 0xe8, 0x39, 0xa4,
	0xd6, 0xb5, 0xce, 0x5b, 0x96, 0x63, 0xdd, 0x89, 0x30, 0x97, 0x7d, 0x2f, 0x0d, 0x03, 0xbc, 0x3e,
	0x51, 0x28, 0xca, 0xfd, 0x87, 0x34, 0xec, 0x30, 0x16, 0x45, 0xd8, 0xae, 0xbe, 0xc7, 0x82, 0xfc,
	0x8c, 0x05, 0xf9, 0x1d, 0x0b, 0xf2, 0xf9, 0x57, 0x1c, 0xbc, 0x2c, 0xd6, 0x37, 0x83, 0xe6, 0x3c,
	0xc5, 0xbf, 0xbc, 0xfd, 0x0f, 0x00, 0x00, 0xff, 0xff, 0x24, 0x6c, 0x11, 0x1b, 0x5e, 0x01, 0x00,
	0x00,
}

func (m *DBGoodsOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DBGoodsOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DBGoodsOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Buyer != 0 {
		i = encodeVarintDbMarket(dAtA, i, uint64(m.Buyer))
		i--
		dAtA[i] = 0x58
	}
	if m.Seller != 0 {
		i = encodeVarintDbMarket(dAtA, i, uint64(m.Seller))
		i--
		dAtA[i] = 0x50
	}
	if m.Status != 0 {
		i = encodeVarintDbMarket(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x48
	}
	if m.SoldAt != 0 {
		i = encodeVarintDbMarket(dAtA, i, uint64(m.SoldAt))
		i--
		dAtA[i] = 0x40
	}
	if m.OpenAt != 0 {
		i = encodeVarintDbMarket(dAtA, i, uint64(m.OpenAt))
		i--
		dAtA[i] = 0x38
	}
	if m.PublishAt != 0 {
		i = encodeVarintDbMarket(dAtA, i, uint64(m.PublishAt))
		i--
		dAtA[i] = 0x30
	}
	if m.Gas != 0 {
		i = encodeVarintDbMarket(dAtA, i, uint64(m.Gas))
		i--
		dAtA[i] = 0x28
	}
	if m.Price != 0 {
		i = encodeVarintDbMarket(dAtA, i, uint64(m.Price))
		i--
		dAtA[i] = 0x20
	}
	if m.GoodsNum != 0 {
		i = encodeVarintDbMarket(dAtA, i, uint64(m.GoodsNum))
		i--
		dAtA[i] = 0x18
	}
	if m.GoodsId != 0 {
		i = encodeVarintDbMarket(dAtA, i, uint64(m.GoodsId))
		i--
		dAtA[i] = 0x10
	}
	if m.OrderUuid != 0 {
		i = encodeVarintDbMarket(dAtA, i, uint64(m.OrderUuid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintDbMarket(dAtA []byte, offset int, v uint64) int {
	offset -= sovDbMarket(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *DBGoodsOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrderUuid != 0 {
		n += 1 + sovDbMarket(uint64(m.OrderUuid))
	}
	if m.GoodsId != 0 {
		n += 1 + sovDbMarket(uint64(m.GoodsId))
	}
	if m.GoodsNum != 0 {
		n += 1 + sovDbMarket(uint64(m.GoodsNum))
	}
	if m.Price != 0 {
		n += 1 + sovDbMarket(uint64(m.Price))
	}
	if m.Gas != 0 {
		n += 1 + sovDbMarket(uint64(m.Gas))
	}
	if m.PublishAt != 0 {
		n += 1 + sovDbMarket(uint64(m.PublishAt))
	}
	if m.OpenAt != 0 {
		n += 1 + sovDbMarket(uint64(m.OpenAt))
	}
	if m.SoldAt != 0 {
		n += 1 + sovDbMarket(uint64(m.SoldAt))
	}
	if m.Status != 0 {
		n += 1 + sovDbMarket(uint64(m.Status))
	}
	if m.Seller != 0 {
		n += 1 + sovDbMarket(uint64(m.Seller))
	}
	if m.Buyer != 0 {
		n += 1 + sovDbMarket(uint64(m.Buyer))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovDbMarket(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozDbMarket(x uint64) (n int) {
	return sovDbMarket(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DBGoodsOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDbMarket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DBGoodsOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DBGoodsOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderUuid", wireType)
			}
			m.OrderUuid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDbMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderUuid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodsId", wireType)
			}
			m.GoodsId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDbMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GoodsId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodsNum", wireType)
			}
			m.GoodsNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDbMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GoodsNum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			m.Price = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDbMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Price |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gas", wireType)
			}
			m.Gas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDbMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gas |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublishAt", wireType)
			}
			m.PublishAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDbMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PublishAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenAt", wireType)
			}
			m.OpenAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDbMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpenAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SoldAt", wireType)
			}
			m.SoldAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDbMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SoldAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDbMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seller", wireType)
			}
			m.Seller = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDbMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seller |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buyer", wireType)
			}
			m.Buyer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDbMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Buyer |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDbMarket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDbMarket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDbMarket(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDbMarket
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDbMarket
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDbMarket
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDbMarket
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupDbMarket
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthDbMarket
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthDbMarket        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDbMarket          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupDbMarket = fmt.Errorf("proto: unexpected end of group")
)
